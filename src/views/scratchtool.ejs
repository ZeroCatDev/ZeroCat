var htmlElement = document.getElementsByTagName("html")[0];

const AppState = {
  bootstrapped: false,
  uiMounted: false,
  appInitialized: false,
  listeners: {
    commitBranchChangeBound: false,
    cloudDialogLifecycleBound: false,
    cloudListDelegatedBound: false,
    quickSaveSettingBound: false,
  },
  save: {
    inFlight: false,
    phase: "idle",
  },
  load: {
    seq: 0,
    activeSeq: 0,
    warnedRef: "",
  },
  settings: {
    showDevQuickSave: false,
  },
};

const CLOUD_UI_RENDER_INTERVAL_MS = 200;
const CLOUD_VM_SYNC_INTERVAL_MS = 500;
const RESOURCE_TRACKER_RENDER_INTERVAL_MS = 100;

// Configuration management
const ZCConfig = {
  frontend: {
    url: "<%= global.config['urls.frontend'] %>",
    getPath: function (path) {
      return `${this.url}${path}`;
    },
  },
  api: {
    url: "<%= global.config['urls.backend'] %>",
    getPath: function (path) {
      return `${this.url}${path}`;
    },
  },
  s3: {
    staticUrl: "<%= global.config['s3.staticurl'] %>",
  },
};

// --- Refactored Application Management & Resource Loading ---
const App = {
  initialize: async function () {
    if (AppState.bootstrapped) return;
    AppState.bootstrapped = true;
    try {
      loadStyle(ZCConfig.frontend.getPath("/scratchtool/mdui.css"));
      ensureLoadingDialogStyle();

      await this.loadScript(ZCConfig.frontend.getPath("/scratchtool/jquery.3.7.1.js"));
      await this.loadScript(ZCConfig.frontend.getPath("/scratchtool/mdui.global.js"));

      const runInitialization = () => {
        initUIComponents();
        initialize();
      };

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", runInitialization, { once: true });
      } else {
        runInitialization();
      }
    } catch (error) {
      console.error("Application initialization failed:", error);
      alert(`应用初始化失败: ${error.message}`);
    }
  },

  loadScript: (src) => {
    return new Promise((resolve, reject) => {
      const existingScript = document.querySelector(`script[src="${src}"]`);
      if (existingScript) {
        resolve();
        return;
      }
      const script = document.createElement('script');
      script.src = src;
      script.onload = () => {
        script.dataset.loaded = "true";
        resolve();
      };
      script.onerror = () => reject(new Error(`Script load error for ${src}`));
      document.head.appendChild(script);
    });
  },
};

function ensureLoadingDialogStyle() {
  if (document.getElementById("zc-loading-dialog-style")) return;
  const customStyle = document.createElement("style");
  customStyle.id = "zc-loading-dialog-style";
  customStyle.textContent = `
    .loading-dialog {
      z-index: 999 !important;
      pointer-events: none !important;
    }
    .loading-dialog::part(overlay) {
      background: rgba(0, 0, 0, 0.3) !important;
      pointer-events: none !important;
    }
    .loading-dialog::part(panel) {
      pointer-events: auto !important;
    }
  `;
  document.head.appendChild(customStyle);
}

const loadStyle = (href) => {
  if (document.querySelector(`link[rel="stylesheet"][href="${href}"]`)) return;
  const link = document.createElement("link");
  link.rel = "stylesheet";
  link.href = href;
  document.head.appendChild(link);
};

window.addEventListener("load", () => {
  App.initialize();
}, { once: true });


// 将依赖mdui的UI操作封装到这个函数中
function initUIComponents() {
  htmlElement.classList.add("mdui-theme-dark");
  mdui.setColorScheme("#2087fd");
  window.UIManager = {
    showSnackbar: function (message) {
      mdui.snackbar({ message, closeable: true });
    },
    showAlert: function (options) {
      mdui.alert(options);
    },
  };
}

// 令牌管理工具
const TokenManager = {
  // 获取当前令牌
  getToken: function () {
    return localStorage.getItem("token");
  },

  // 保存令牌信息
  saveTokens: function (accessToken, refreshToken) {
    localStorage.setItem("token", accessToken);
    if (refreshToken) {
      localStorage.setItem("refreshToken", refreshToken);
    }
  },
};


// Description: ZeroCat Scratch Tool
let zcvm, zcgui;
let _pid = 0;
let logText,
  zctab,
  assetUploadDialog,
  commitDialogElement,
  commitBranchNameInput,
  commitBranchRadioGroup,
  quickSaveSettingButton,
  cloudDialog,
  cloudProjectIdInput,
  cloudUsernameInput,
  cloudConnStatusInput,
  cloudVarsCountInput,
  cloudVarsListContainer,
  cloudSyncTimer = null,
  currentUserId = null,  // 当前用户ID，由后端API获取
  projectjson = "null",
  projectinfo = {};
let commitInfo = {};
let commituser = {};
let authorinfocard = {};
let authorinfoavatar = {};

const SETTINGS_KEYS = {
  showDevQuickSave: "zc:scratchtool:show-dev-quick-save",
};

const DEV_QUICK_SAVE_BUTTON = {
  id: "dev-save-button",
  text: "开发环境保存",
  onclick: () => quickSaveToDevelop(),
};

const defaultButtons = [
  { id: "open-zerocat-tab", text: "信息", onclick: () => updateZerocatTab() },
  { id: "save-button", text: "保存", onclick: () => openCommitDialog() },
  { id: "set-thumbnail-button", text: "舞台截图设为封面", onclick: () => setProjectThumbnail() },
];
const buttons = [];

function readPersistentValue(key) {
  try {
    const fromStrong = window.localstrongs?.getItem?.(key);
    if (fromStrong !== undefined && fromStrong !== null) {
      return String(fromStrong);
    }
  } catch (error) {
    console.warn("[settings] localstrongs getItem failed:", error);
  }
  try {
    const fromLocal = localStorage.getItem(key);
    if (fromLocal !== undefined && fromLocal !== null) {
      return String(fromLocal);
    }
  } catch (error) {
    console.warn("[settings] localStorage getItem failed:", error);
  }
  return null;
}

function writePersistentValue(key, value) {
  const stringValue = String(value);
  let written = false;
  try {
    if (window.localstrongs?.setItem) {
      window.localstrongs.setItem(key, stringValue);
      written = true;
    } else if (window.localstrongs) {
      window.localstrongs[key] = stringValue;
      written = true;
    }
  } catch (error) {
    console.warn("[settings] localstrongs setItem failed:", error);
  }
  try {
    localStorage.setItem(key, stringValue);
    written = true;
  } catch (error) {
    console.warn("[settings] localStorage setItem failed:", error);
  }
  return written;
}

function readBooleanSetting(key, fallback = false) {
  const raw = readPersistentValue(key);
  if (raw === null) return fallback;
  const normalized = raw.trim().toLowerCase();
  if (normalized === "1" || normalized === "true" || normalized === "yes" || normalized === "on") return true;
  if (normalized === "0" || normalized === "false" || normalized === "no" || normalized === "off") return false;
  return fallback;
}

function writeBooleanSetting(key, value) {
  return writePersistentValue(key, value ? "1" : "0");
}

function rebuildDefaultButtons() {
  buttons.length = 0;
  buttons.push(...defaultButtons);
  if (AppState.settings.showDevQuickSave) {
    buttons.push(DEV_QUICK_SAVE_BUTTON);
  }
}

function restoreDefaultButtons() {
  rebuildDefaultButtons();
}

const cloudWsState = {
  socket: null,
  provider: null,
  projectId: null,
  username: "",
  wsUrl: "",
  status: "idle",
  lastStatusText: "",
  variables: {},
  lastRenderedSignature: "",
  renderTimer: null,
  renderPending: false,
  autoConnect: true,
  autoReconnect: true,
  manualDisconnect: false,
  retryTimer: null,
  retryCount: 0,
  wsCandidates: [],
  wsCandidateIndex: 0,
  globalListenersInstalled: false,
  pendingUpdates: {},
  handshakeSent: false,
};

function getQueryStringParameter(name) {
  return new URL(window.location.href).searchParams.get(name);
}

function getCurrentTime() {
  const now = new Date();
  return `${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}`;
}

function getCurrentDateTimeString() {
  return new Date().toLocaleString();
}

// 封装showSnackbar函数，确保mdui已加载
function showSnackbar(text) {
  if (window.UIManager) {
    UIManager.showSnackbar(text);
  } else {
    // 如果mdui未加载，使用console.log作为备选
    console.log(text);
  }
}

function getErrorMessage(error, fallback = "请求失败") {
  return error?.responseJSON?.message || error?.message || error?.statusText || fallback;
}

function buildErrorDescription(error, prefix = "错误") {
  return `${prefix}: ${getErrorMessage(error)}`;
}

function getActiveVm() {
  return zcvm || window.vm || null;
}

function getCloudProjectId() {
  const fromInput = Number((cloudProjectIdInput?.value || "").trim());
  if (Number.isInteger(fromInput) && fromInput > 0) return fromInput;
  if (Number.isInteger(_pid) && _pid > 0) return _pid;
  const fromQuery = Number(getQueryStringParameter("id"));
  if (Number.isInteger(fromQuery) && fromQuery > 0) return fromQuery;
  return null;
}

function getCloudUsername() {
  const fromInput = (cloudUsernameInput?.value || "").trim();
  if (fromInput) return fromInput;
  return (localStorage.getItem("zc:cloud-username") || localStorage.getItem("zc:username") || "").trim();
}

function getCloudToken() {
  const localStrongsToken = window.localstrongs?.getItem?.("token") || window.localstrongs?.token;
  if (localStrongsToken) return localStrongsToken;
  return localStorage.getItem("token") || "";
}

function buildCloudWsUrlCandidates(token) {
  const endpointPath = "/scratch/cloud/ws";
  const sources = [
    ZCConfig.api.getPath(endpointPath),
    `${window.location.origin}${endpointPath}`,
    ZCConfig.api.url,
  ];
  const results = [];

  const addCandidate = (urlString) => {
    if (!urlString) return;
    if (!results.includes(urlString)) results.push(urlString);
  };

  // 根据当前页面协议决定优先使用的 WebSocket 协议
  const isSecure = window.location.protocol === "https:";
  const preferredProtocol = isSecure ? "wss:" : "ws:";
  const fallbackProtocol = isSecure ? "ws:" : "wss:";

  for (const source of sources) {
    let base;
    try {
      base = new URL(source, window.location.origin);
    } catch (error) {
      console.warn("[cloud] Invalid URL source:", source, error);
      continue;
    }
    base.pathname = endpointPath;
    base.hash = "";

    // 优先使用与当前页面协议匹配的 WebSocket 协议，避免混合内容问题
    const protocolOrder = [preferredProtocol, fallbackProtocol];

    for (const protocol of protocolOrder) {
      const candidate = new URL(base.toString());
      candidate.protocol = protocol;
      candidate.search = "";
      if (token) candidate.searchParams.set("token", token);
      addCandidate(candidate.toString());
    }
  }

  return results;
}

function normalizeCloudWsUrl(urlLike, token) {
  try {
    const url = new URL(String(urlLike || ""), window.location.origin);

    // 根据协议类型转换为对应的 WebSocket 协议
    if (url.protocol === "https:") {
      url.protocol = "wss:";
    } else if (url.protocol === "http:") {
      url.protocol = "ws:";
    } else if (url.protocol !== "ws:" && url.protocol !== "wss:") {
      // 如果既不是 ws 也不是 wss，根据当前页面协议选择
      url.protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
    }

    url.hash = "";
    if (token) url.searchParams.set("token", token);
    return url.toString();
  } catch (error) {
    console.warn("[cloud] Failed to normalize WebSocket URL:", urlLike, error);
    return "";
  }
}

function appendCloudLog(text) {
  console.log(`[cloud ${getCurrentTime()}] ${text}`);
}

function setCloudConnectionStatus(status, detail = "") {
  cloudWsState.status = status;
  const statusText = detail ? `${status}: ${detail}` : status;
  if (cloudConnStatusInput && cloudConnStatusInput.value !== statusText) {
    cloudConnStatusInput.value = statusText;
  }
  if (statusText === cloudWsState.lastStatusText) return;
  cloudWsState.lastStatusText = statusText;
  appendCloudLog(`[status] ${statusText}`);
}

function collectVmCloudVariables() {
  const vm = getActiveVm();
  const stage = vm?.runtime?.getTargetForStage?.();
  const variables = Object.values(stage?.variables || {}).filter((item) => item && item.isCloud && typeof item.name === "string");
  const map = {};
  for (const item of variables) {
    map[item.name] = String(item.value ?? "");
  }
  return map;
}

function queueCloudUpdate(method, name, value) {
  const normalizedName = String(name || "").trim();
  if (!normalizedName) return false;
  if (cloudWsState.manualDisconnect) {
    cloudWsState.manualDisconnect = false;
  }

  if (method === "delete") {
    const existing = cloudWsState.pendingUpdates[normalizedName];
    if (existing && existing.method === "delete") return true;
    cloudWsState.pendingUpdates[normalizedName] = { method: "delete" };
  } else {
    const normalizedValue = String(value ?? "");
    const existing = cloudWsState.pendingUpdates[normalizedName];
    if (existing && existing.method === "set" && existing.value === normalizedValue) return true;
    cloudWsState.pendingUpdates[normalizedName] = { method: "set", value: normalizedValue };
  }

  cloudAutoConnectIfNeeded({ force: true });
  scheduleCloudReconnect("pending");
  return true;
}

function flushPendingCloudUpdates() {
  const socket = cloudWsState.socket;
  if (!socket || socket.readyState !== WebSocket.OPEN) return false;
  if (!cloudWsState.handshakeSent) {
    sendCloudHandshake();
  }
  const pending = cloudWsState.pendingUpdates;
  const names = Object.keys(pending);
  if (names.length === 0) return true;

  for (const name of names) {
    const item = pending[name];
    if (item.method === "delete") {
      sendCloudUpdate("delete", { name });
      appendCloudLog(`[out] delete ${name}`);
    } else if (item.method === "set") {
      sendCloudUpdate("set", { name, value: item.value });
      appendCloudLog(`[out] ${name} = ${item.value}`);
    }
  }

  cloudWsState.pendingUpdates = {};
  return true;
}

function areCloudMapsEqual(a, b) {
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  if (keysA.length !== keysB.length) return false;
  for (const key of keysA) {
    if (!Object.prototype.hasOwnProperty.call(b, key) || a[key] !== b[key]) {
      return false;
    }
  }
  return true;
}

function getCloudVariableSignature(variables) {
  const names = Object.keys(variables).sort((a, b) => a.localeCompare(b, "zh-Hans-CN"));
  return names.map((name) => `${name}\u0000${variables[name] ?? ""}`).join("\u0001");
}

function escapeAttrSelector(value) {
  if (window.CSS && typeof window.CSS.escape === "function") {
    return window.CSS.escape(value);
  }
  return String(value).replace(/["\\]/g, "\\$&");
}

function ensureCloudListDelegatedHandlers() {
  if (AppState.listeners.cloudListDelegatedBound || !cloudVarsListContainer) return;
  const findElementFromEvent = (event, selector) => {
    if (event.target instanceof Element) {
      const direct = event.target.closest(selector);
      if (direct) return direct;
    }
    if (typeof event.composedPath === "function") {
      const path = event.composedPath();
      for (const item of path) {
        if (item instanceof Element && item.matches(selector)) {
          return item;
        }
      }
    }
    return null;
  };

  cloudVarsListContainer.addEventListener("click", (event) => {
    const saveButton = findElementFromEvent(event, "mdui-button[data-cloud-save='1']");
    if (!saveButton) return;
    const name = saveButton.getAttribute("data-cloud-name") || "";
    if (!name) return;
    const valueField = cloudVarsListContainer.querySelector(`mdui-text-field[data-cloud-name="${escapeAttrSelector(name)}"]`);
    cloudSetVariableByName(name, valueField?.value ?? "");
  });

  cloudVarsListContainer.addEventListener("keydown", (event) => {
    if (event.key !== "Enter") return;
    const valueField = findElementFromEvent(event, "mdui-text-field[data-cloud-name]");
    if (!valueField) return;
    event.preventDefault();
    const name = valueField.getAttribute("data-cloud-name") || "";
    cloudSetVariableByName(name, valueField.value ?? "");
  });

  AppState.listeners.cloudListDelegatedBound = true;
}

function renderCloudVariables({ force = false } = {}) {
  if (!cloudVarsListContainer) return;
  ensureCloudListDelegatedHandlers();

  const names = Object.keys(cloudWsState.variables).sort((a, b) => a.localeCompare(b, "zh-Hans-CN"));
  const signature = getCloudVariableSignature(cloudWsState.variables);
  if (!force && signature === cloudWsState.lastRenderedSignature) return;
  cloudWsState.lastRenderedSignature = signature;

  if (cloudVarsCountInput) {
    cloudVarsCountInput.value = String(names.length);
  }

  if (names.length === 0) {
    const empty = document.createElement("div");
    empty.textContent = "当前没有云变量";
    empty.style.opacity = "0.75";
    empty.style.padding = "8px 0";
    cloudVarsListContainer.replaceChildren(empty);
    return;
  }

  const fragment = document.createDocumentFragment();
  for (const name of names) {
    const row = document.createElement("div");
    row.style.display = "grid";
    row.style.gridTemplateColumns = "minmax(180px, 1fr) minmax(180px, 1fr) auto";
    row.style.gap = "8px";
    row.style.marginBottom = "8px";

    const nameField = document.createElement("mdui-text-field");
    nameField.label = "变量名";
    nameField.value = name;
    nameField.readOnly = true;
    nameField.setAttribute("readonly", "");

    const valueField = document.createElement("mdui-text-field");
    valueField.label = "变量值";
    valueField.value = cloudWsState.variables[name] ?? "";
    valueField.setAttribute("data-cloud-name", name);

    const saveButton = document.createElement("mdui-button");
    saveButton.variant = "filled";
    saveButton.setAttribute("variant", "filled");
    saveButton.textContent = "保存";
    saveButton.setAttribute("data-cloud-save", "1");
    saveButton.setAttribute("data-cloud-name", name);

    row.appendChild(nameField);
    row.appendChild(valueField);
    row.appendChild(saveButton);
    fragment.appendChild(row);
  }
  cloudVarsListContainer.replaceChildren(fragment);
}

function scheduleCloudVariablesRender({ force = false } = {}) {
  if (force) {
    if (cloudWsState.renderTimer) {
      clearTimeout(cloudWsState.renderTimer);
      cloudWsState.renderTimer = null;
    }
    cloudWsState.renderPending = false;
    renderCloudVariables({ force: true });
    return;
  }
  if (cloudWsState.renderPending) return;
  cloudWsState.renderPending = true;
  cloudWsState.renderTimer = setTimeout(() => {
    cloudWsState.renderPending = false;
    cloudWsState.renderTimer = null;
    renderCloudVariables();
  }, CLOUD_UI_RENDER_INTERVAL_MS);
}

function refreshCloudVariablesFromVm({ forceRender = false } = {}) {
  const vmVariables = collectVmCloudVariables();
  if (forceRender || !areCloudMapsEqual(vmVariables, cloudWsState.variables)) {
    cloudWsState.variables = vmVariables;
    scheduleCloudVariablesRender({ force: forceRender });
  }
}

function startCloudSyncTimer() {
  if (cloudSyncTimer) return;
  cloudSyncTimer = setInterval(() => {
    refreshCloudVariablesFromVm();
  }, CLOUD_VM_SYNC_INTERVAL_MS);
}

function stopCloudSyncTimer() {
  if (!cloudSyncTimer) return;
  clearInterval(cloudSyncTimer);
  cloudSyncTimer = null;
}

function clearCloudRetryTimer() {
  if (!cloudWsState.retryTimer) return;
  clearTimeout(cloudWsState.retryTimer);
  cloudWsState.retryTimer = null;
}

function scheduleCloudReconnect(reason = "") {
  if (!cloudWsState.autoReconnect) return;
  if (cloudWsState.manualDisconnect) return;
  if (cloudWsState.retryTimer) return;
  const socket = cloudWsState.socket;
  if (socket && (socket.readyState === WebSocket.CONNECTING || socket.readyState === WebSocket.OPEN)) {
    return;
  }

  cloudWsState.retryCount += 1;
  const exp = Math.min(cloudWsState.retryCount - 1, 6);
  const baseDelay = 1000 * Math.pow(2, Math.max(0, exp));
  const jitter = Math.floor(Math.random() * 500);
  const delayMs = Math.min(30000, baseDelay + jitter);
  setCloudConnectionStatus("retrying", `${delayMs}ms ${reason}`.trim());

  cloudWsState.retryTimer = setTimeout(() => {
    cloudWsState.retryTimer = null;
    connectCloudWs({ auto: true, silent: true });
  }, delayMs);
}

function cloudAutoConnectIfNeeded({ force = false } = {}) {
  if (!cloudWsState.autoConnect) return false;
  if (cloudWsState.manualDisconnect && !force) return false;
  if (force) {
    cloudWsState.manualDisconnect = false;
  }
  const socket = cloudWsState.socket;
  if (socket && (socket.readyState === WebSocket.CONNECTING || socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CLOSING)) {
    return false;
  }
  return connectCloudWs({ auto: true, silent: true });
}

function installCloudGlobalListeners() {
  if (cloudWsState.globalListenersInstalled) return;
  cloudWsState.globalListenersInstalled = true;

  window.addEventListener("online", () => {
    cloudAutoConnectIfNeeded({ force: true });
  });

  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "visible") {
      cloudAutoConnectIfNeeded();
    }
  });
}

function parseCloudFrames(raw) {
  return String(raw || "")
    .split("\n")
    .map((line) => line.trim())
    .filter(Boolean)
    .map((line) => {
      try {
        return JSON.parse(line);
      } catch (error) {
        appendCloudLog(`[parse-error] ${line}`);
        return null;
      }
    })
    .filter(Boolean);
}

function sendCloudWsMessage(message) {
  const socket = cloudWsState.socket;
  if (!socket || socket.readyState !== WebSocket.OPEN) {
    appendCloudLog("[send] skipped, websocket not open");
    return false;
  }
  socket.send(JSON.stringify(message));
  return true;
}

function sendCloudHandshake() {
  if (!cloudWsState.projectId || !cloudWsState.username) return false;
  const ok = sendCloudWsMessage({
    method: "handshake",
    project_id: String(cloudWsState.projectId),
    user: cloudWsState.username,
  });
  if (ok) {
    cloudWsState.handshakeSent = true;
    appendCloudLog(`[handshake] project_id=${cloudWsState.projectId}, user=${cloudWsState.username}`);
  }
  return ok;
}

function sendCloudUpdate(method, payload) {
  if (!cloudWsState.projectId || !cloudWsState.username) {
    appendCloudLog("[send] skipped, project_id or user missing");
    return false;
  }
  return sendCloudWsMessage({
    method,
    project_id: String(cloudWsState.projectId),
    user: cloudWsState.username,
    ...payload,
  });
}

function createScratchCloudProvider() {
  return {
    createVariable: (name, value) => {
      const normalizedValue = String(value ?? "");
      cloudWsState.variables[name] = normalizedValue;
      scheduleCloudVariablesRender();
      return sendCloudUpdate("create", { name, value: normalizedValue });
    },
    updateVariable: (name, value) => {
      const normalizedValue = String(value ?? "");
      cloudWsState.variables[name] = normalizedValue;
      scheduleCloudVariablesRender();
      return sendCloudUpdate("set", { name, value: normalizedValue });
    },
    renameVariable: (oldName, newName) => {
      if (Object.prototype.hasOwnProperty.call(cloudWsState.variables, oldName)) {
        const value = cloudWsState.variables[oldName];
        delete cloudWsState.variables[oldName];
        cloudWsState.variables[newName] = value;
        scheduleCloudVariablesRender();
      }
      return sendCloudUpdate("rename", { name: oldName, new_name: newName });
    },
    deleteVariable: (name) => {
      if (Object.prototype.hasOwnProperty.call(cloudWsState.variables, name)) {
        delete cloudWsState.variables[name];
        scheduleCloudVariablesRender();
      }
      return sendCloudUpdate("delete", { name });
    },
    requestCloseConnection: () => disconnectCloudWs({ manual: false }),
  };
}

function handleCloudSocketMessage(data) {
  const vm = getActiveVm();
  let changed = false;
  for (const message of parseCloudFrames(data)) {
    if (message.method === "set" && typeof message.name === "string") {
      const value = message.value;
      vm?.postIOData?.("cloud", { varUpdate: { name: message.name, value } });
      const normalizedValue = String(value ?? "");
      if (cloudWsState.variables[message.name] !== normalizedValue) {
        cloudWsState.variables[message.name] = normalizedValue;
        changed = true;
      }
      appendCloudLog(`[in] ${message.name} = ${normalizedValue}`);
      continue;
    }
    appendCloudLog(`[in] ignored method=${message.method || "unknown"}`);
  }
  if (changed) {
    scheduleCloudVariablesRender();
  }
}

function connectCloudWs(options = {}) {
  const silent = Boolean(options.silent);
  const shouldAutoRetry = Boolean(options.auto);
  const existingSocket = cloudWsState.socket;
  if (existingSocket && (existingSocket.readyState === WebSocket.CONNECTING || existingSocket.readyState === WebSocket.OPEN || existingSocket.readyState === WebSocket.CLOSING)) {
    if (!silent) {
      appendCloudLog("[connect] skipped, socket already active");
    }
    return false;
  }
  const vm = getActiveVm();
  if (!vm) {
    setCloudConnectionStatus("waiting_vm");
    if (!silent) showSnackbar("Scratch VM 尚未就绪");
    if (shouldAutoRetry) scheduleCloudReconnect("vm");
    return false;
  }

  const projectId = Number(options.projectId || getCloudProjectId());
  if (!Number.isInteger(projectId) || projectId <= 0) {
    setCloudConnectionStatus("waiting_project_id");
    if (!silent) showSnackbar("无效 project_id");
    if (shouldAutoRetry) scheduleCloudReconnect("project_id");
    return false;
  }

  const username = (options.username || getCloudUsername()).trim();
  if (!username) {
    setCloudConnectionStatus("waiting_user");
    if (!silent) showSnackbar("握手用户名不能为空");
    if (shouldAutoRetry) scheduleCloudReconnect("username");
    return false;
  }

  const token = String(options.token || getCloudToken() || "").trim();
  if (!token) {
    appendCloudLog("[auth] token missing, try anonymous handshake");
  }

  const directUrl = options.wsUrl ? normalizeCloudWsUrl(options.wsUrl, token) : "";
  const wsCandidates = directUrl ? [directUrl] : buildCloudWsUrlCandidates(token);
  if (wsCandidates.length === 0) {
    setCloudConnectionStatus("error", "no ws url candidates");
    if (shouldAutoRetry) scheduleCloudReconnect("no-candidate");
    return false;
  }

  clearCloudRetryTimer();
  cloudWsState.manualDisconnect = false;

  cloudWsState.wsCandidates = wsCandidates;
  const providedIndex = Number.isInteger(options.wsCandidateIndex)
    ? options.wsCandidateIndex
    : cloudWsState.wsCandidateIndex;
  const normalizedIndex = ((providedIndex % wsCandidates.length) + wsCandidates.length) % wsCandidates.length;
  cloudWsState.wsCandidateIndex = normalizedIndex;
  const wsUrl = wsCandidates[normalizedIndex];

  if (cloudWsState.socket && cloudWsState.socket.readyState !== WebSocket.CLOSED) {
    try {
      cloudWsState.socket.close(1000, "reconnect");
    } catch (error) {
      console.error("close old cloud ws error:", error);
    }
    cloudWsState.socket = null;
  }

  const provider = createScratchCloudProvider();
  vm.setCloudProvider(provider);
  cloudWsState.provider = provider;
  cloudWsState.projectId = projectId;
  cloudWsState.username = username;
  cloudWsState.wsUrl = wsUrl;
  cloudWsState.variables = collectVmCloudVariables();

  if (cloudProjectIdInput) cloudProjectIdInput.value = String(projectId);
  if (cloudUsernameInput) cloudUsernameInput.value = username;
  scheduleCloudVariablesRender({ force: true });

  localStorage.setItem("zc:cloud-username", username);

  let socket;
  try {
    socket = new WebSocket(wsUrl);
  } catch (error) {
    setCloudConnectionStatus("connect_error", String(error?.message || error));
    if (shouldAutoRetry) {
      cloudWsState.wsCandidateIndex = (cloudWsState.wsCandidateIndex + 1) % wsCandidates.length;
      scheduleCloudReconnect("constructor");
    }
    return false;
  }
  cloudWsState.socket = socket;
  setCloudConnectionStatus("connecting", `${wsUrl} [${normalizedIndex + 1}/${wsCandidates.length}]`);

  socket.addEventListener("open", () => {
    if (cloudWsState.socket !== socket) return;
    clearCloudRetryTimer();
    cloudWsState.retryCount = 0;
    setCloudConnectionStatus("open");
    cloudWsState.handshakeSent = false;
    sendCloudHandshake();
    setTimeout(() => {
      flushPendingCloudUpdates();
    }, 0);
  });

  socket.addEventListener("message", (event) => {
    if (cloudWsState.socket !== socket) return;
    handleCloudSocketMessage(event.data);
  });

  socket.addEventListener("close", (event) => {
    if (cloudWsState.socket !== socket) return;
    const detail = `code=${event.code}, reason=${event.reason || "-"}`;
    setCloudConnectionStatus("closed", detail);
    cloudWsState.socket = null;
    cloudWsState.handshakeSent = false;
    const currentVm = getActiveVm();
    if (currentVm && cloudWsState.provider) {
      currentVm.setCloudProvider(null);
    }
    cloudWsState.provider = null;
    if (!cloudWsState.manualDisconnect) {
      cloudWsState.wsCandidateIndex = (cloudWsState.wsCandidateIndex + 1) % cloudWsState.wsCandidates.length;
      scheduleCloudReconnect(`close:${event.code}`);
    }
  });

  socket.addEventListener("error", () => {
    if (cloudWsState.socket !== socket) return;
    setCloudConnectionStatus("error");
  });

  return true;
}

function disconnectCloudWs({ manual = true } = {}) {
  cloudWsState.manualDisconnect = manual;
  if (manual) {
    cloudWsState.retryCount = 0;
  }
  clearCloudRetryTimer();
  const socket = cloudWsState.socket;
  if (socket) {
    try {
      socket.close(1000, "client close");
    } catch (error) {
      console.error("close cloud ws error:", error);
    }
  }
  cloudWsState.socket = null;
  const vm = getActiveVm();
  if (vm && cloudWsState.provider) {
    vm.setCloudProvider(null);
  }
  cloudWsState.provider = null;
  setCloudConnectionStatus("disconnected");
}

function cloudConnect() {
  cloudWsState.manualDisconnect = false;
  connectCloudWs({ projectId: getCloudProjectId(), username: getCloudUsername(), auto: true });
}

function cloudDisconnect() {
  disconnectCloudWs({ manual: true });
}

function openCloudToolDialog() {
  if (!cloudDialog) {
    showSnackbar("云变量工具未初始化");
    return;
  }
  cloudDialog.open = true;
  refreshCloudVariablesFromVm({ forceRender: true });
  startCloudSyncTimer();
  cloudAutoConnectIfNeeded();
}

function cloudSetVariableByName(name, value) {
  const socket = cloudWsState.socket;
  if (!socket || socket.readyState !== WebSocket.OPEN) {
    const normalizedName = String(name || "").trim();
    if (!normalizedName) {
      showSnackbar("变量名不能为空");
      return;
    }
    const normalizedValue = String(value ?? "");
    queueCloudUpdate("set", normalizedName, normalizedValue);
    cloudWsState.variables[normalizedName] = normalizedValue;
    scheduleCloudVariablesRender();
    appendCloudLog(`[out] queued ${normalizedName} = ${normalizedValue}`);
    showSnackbar("连接已断开，已加入队列并尝试重连");
    return;
  }

  const vm = getActiveVm();
  const cloudDevice = vm?.runtime?.ioDevices?.cloud;
  const normalizedName = String(name || "").trim();
  if (!normalizedName) {
    showSnackbar("变量名不能为空");
    return;
  }
  const normalizedValue = String(value ?? "");

  if (vm && cloudDevice?.requestUpdateVariable) {
    cloudDevice.requestUpdateVariable(normalizedName, normalizedValue);
  } else {
    sendCloudUpdate("set", { name: normalizedName, value: normalizedValue });
  }

  cloudWsState.variables[normalizedName] = normalizedValue;
  scheduleCloudVariablesRender();
  appendCloudLog(`[out] ${normalizedName} = ${normalizedValue}`);
}

function cloudRefreshVariables() {
  refreshCloudVariablesFromVm({ forceRender: true });
}

window.CloudExternal = {
  connect: (options = {}) => connectCloudWs(options),
  disconnect: () => disconnectCloudWs({ manual: true }),
  set: (name, value) => cloudSetVariableByName(name, value),
  list: () => Object.keys(cloudWsState.variables).sort().map((name) => ({ name, value: cloudWsState.variables[name] })),
  refresh: () => cloudRefreshVariables(),
  autoConnect: () => {
    cloudWsState.manualDisconnect = false;
    return cloudAutoConnectIfNeeded({ force: true });
  },
  status: () => ({
    status: cloudWsState.status,
    projectId: cloudWsState.projectId,
    username: cloudWsState.username,
    wsUrl: cloudWsState.wsUrl,
    readyState: cloudWsState.socket ? cloudWsState.socket.readyState : null,
    retryCount: cloudWsState.retryCount,
    candidateIndex: cloudWsState.wsCandidateIndex,
    candidates: cloudWsState.wsCandidates,
  }),
};



function handleInvalidLogin(message) {
  if (window.UIManager) {
    UIManager.showAlert({
      headline: "需要登录",
      description: message || "请先登录后再进行操作",
      confirmText: "打开登录页面",
      cancelText: "取消",
      onConfirm: () => {
        const returnUrl = encodeURIComponent(window.location.href);
        window.open(
          `${ZCConfig.frontend.getPath(
            "/app/account/login"
          )}?return_url=${returnUrl}`,
          "_blank"
        );
      },
    });
  } else {
    if (confirm(`${message || "请先登录后再进行操作"}\n是否打开登录页面?`)) {
      const returnUrl = encodeURIComponent(window.location.href);
      window.open(
        `${ZCConfig.frontend.getPath(
          "/app/account/login"
        )}?return_url=${returnUrl}`,
        "_blank"
      );
    }
  }
  showLoginButton();
}

// 定义一个函数用于加载用户信息
async function loadUserInfo() {
  const token = localStorage.getItem("token");

  if (!token) {
    if (!isEmbed) showLoginButton();
    return;
  }

  // 从后端获取当前用户信息
  try {
    const result = await apiRequest({
      url: `${ZCConfig.api.getPath("/user/me")}`,
      type: "GET",
    });

    if (result && result.data) {
      currentUserId = result.data.id;
      if (!isEmbed) {
        const hasLoginOnlyButton = buttons.length === 1 && buttons[0]?.id === "login-button";
        if (hasLoginOnlyButton) {
          applyToolbarButtonsBySettings();
        }
      }
      // 可选：缓存到 localStorage
      localStorage.setItem("zc:id", String(result.data.id));
      if (result.data.username) {
        localStorage.setItem("zc:cloud-username", result.data.username);
      } else if (result.data.zcusername) {
        localStorage.setItem("zc:cloud-username", result.data.zcusername);
      }
      if (result.data.display_name) {
        localStorage.setItem("zc:username", result.data.display_name);
      }
      cloudAutoConnectIfNeeded({ force: true });
    }
  } catch (error) {
    console.error("获取用户信息失败:", error);
    // Token 无效或过期，显示登录按钮
    if (error.status === 401 && !isEmbed) {
      showLoginButton();
    }
  }
}

function showLoginButton() {
  buttons.length = 0; // 清空按钮数组
  buttons.push({
    id: "login-button",
    text: "登录/注册",
    onclick: () => {
      // 添加当前URL作为return_url参数
      const returnUrl = encodeURIComponent(window.location.href);
      window.open(
        `${ZCConfig.frontend.getPath(
          "/app/account/login"
        )}?return_url=${returnUrl}`,
        "_blank"
      );
    },
  });
  renderButtons();
}

function applyToolbarButtonsBySettings() {
  restoreDefaultButtons();
  renderButtons();
}

function getQuickSaveToggleButtonText(enabled) {
  return enabled ? "已开启" : "已关闭";
}

function updateQuickSaveToggleButton() {
  if (!quickSaveSettingButton) return;
  const enabled = AppState.settings.showDevQuickSave;
  const variant = enabled ? "filled" : "outlined";
  quickSaveSettingButton.textContent = getQuickSaveToggleButtonText(enabled);
  quickSaveSettingButton.variant = variant;
  quickSaveSettingButton.setAttribute("variant", variant);
}

function applySavedSettings() {
  AppState.settings.showDevQuickSave = readBooleanSetting(SETTINGS_KEYS.showDevQuickSave, false);
  updateQuickSaveToggleButton();
  applyToolbarButtonsBySettings();
}

function bindQuickSaveSettingListener() {
  if (!quickSaveSettingButton || AppState.listeners.quickSaveSettingBound) return;
  quickSaveSettingButton.addEventListener("click", () => {
    const enabled = !AppState.settings.showDevQuickSave;
    AppState.settings.showDevQuickSave = enabled;
    writeBooleanSetting(SETTINGS_KEYS.showDevQuickSave, enabled);
    updateQuickSaveToggleButton();
    applyToolbarButtonsBySettings();
    showSnackbar(enabled ? "已显示开发环境保存按钮" : "已隐藏开发环境保存按钮");
  });
  AppState.listeners.quickSaveSettingBound = true;
}

// 辅助函数：发送带 token 的 API 请求
function apiRequest(options) {
  const token = TokenManager.getToken();
  const headers = { ...(options.headers || {}) };

  if (token) {
    headers.Authorization = `Bearer ${token}`;
  }

  return $.ajax({
    timeout: 30000,
    ...options,
    headers,
  });
}

function createToolButtonFromTemplate(template, button) {
  const renderedButton = template.cloneNode(false);
  renderedButton.id = button.id;
  renderedButton.textContent = button.text;
  renderedButton.style.display = "inline-block";
  renderedButton.setAttribute("data-zc-rendered", "1");
  renderedButton.onclick = button.onclick || null;
  return renderedButton;
}

function renderButtons() {
  const zerocattool = document.getElementById("zerocattool");
  if (!zerocattool || !zerocattool.parentNode) return;

  const parent = zerocattool.parentNode;
  const obsoleteButtons = parent.querySelectorAll("[data-zc-rendered='1']");
  for (const item of obsoleteButtons) {
    item.remove();
  }

  const fragment = document.createDocumentFragment();
  for (const button of buttons) {
    const oldButton = document.getElementById(button.id);
    if (oldButton && oldButton !== zerocattool) {
      oldButton.remove();
    }
    fragment.appendChild(createToolButtonFromTemplate(zerocattool, button));
  }
  parent.appendChild(fragment);
  zerocattool.style.display = "none";
}
window.renderButtons = renderButtons;

function setButton(id, text, onclick) {
  const button = document.getElementById(id);
  if (button) {
    button.innerText = text;
    button.onclick = onclick;
  }
}

function updateAssetUploadDialog(description, { open } = {}) {
  if (!assetUploadDialog) return;
  if (typeof description === "string") {
    assetUploadDialog.description = description;
  }
  if (typeof open === "boolean") {
    assetUploadDialog.open = open;
  }
}

// --- Refactored uploadProjectAssets ---
async function uploadProjectAssets() {
  try {
    if (!zcvm || !Array.isArray(zcvm.assets)) {
      showSnackbar("Scratch 引擎尚未就绪，无法保存媒体库");
      return;
    }
    const allAssetIds = zcvm.assets.map((asset) => asset.assetId);

    const checkResult = await apiRequest({
      url: `${ZCConfig.api.getPath("/assets/scratch/check")}`,
      type: "POST",
      dataType: "json",
      contentType: "application/json",
      data: JSON.stringify({ files: allAssetIds }),
    });

    const uploadedFiles = checkResult.data;
    const toUploadFiles = zcvm.assets.filter(
      (asset) => !uploadedFiles.includes(asset.assetId)
    );

    if (logText) {
      logText.value += `[${getCurrentTime()}] 需要上传 ${toUploadFiles.length} 个文件。
`;
    }

    if (toUploadFiles.length === 0) {
      return;
    }

    updateAssetUploadDialog("正在准备上传...", { open: true });

    let completed = 0;
    let failed = 0;
    const total = toUploadFiles.length;
    const concurrency = Math.min(4, total);

    const updateProgress = () => {
      const percent = Math.min(100, Math.floor((completed / total) * 100));
      const failText = failed > 0 ? `，失败 ${failed}` : "";
      updateAssetUploadDialog(`正在上传素材 ${completed}/${total} (${percent}%)${failText}`);
    };

    const uploadSingleAsset = async (asset) => {
      const formData = new FormData();
      formData.append(
        "file",
        new Blob([asset.data], { type: asset.assetType.contentType }),
        `${asset.assetId}.${asset.dataFormat}`
      );

      await apiRequest({
        url: `${ZCConfig.api.getPath("/scratch/assets/" + asset.assetId + "." + asset.dataFormat)}`,
        type: "POST",
        data: formData,
        processData: false,
        contentType: false,
      });
    };

    updateProgress();

    let index = 0;
    const workers = Array.from({ length: concurrency }, () => (async () => {
      while (true) {
        const current = index;
        index += 1;
        if (current >= total) break;
        const asset = toUploadFiles[current];
        try {
          await uploadSingleAsset(asset);
          if (logText) {
            logText.value += `[${getCurrentTime()}] 文件上传成功: ${asset.assetId}.${asset.dataFormat}
`;
          }
          asset.clean = true;
        } catch (error) {
          failed += 1;
          if (logText) {
            logText.value += `[${getCurrentTime()}] 文件上传失败: ${asset.assetId}.${asset.dataFormat}
Error: ${getErrorMessage(error)}
`;
          }
        } finally {
          completed += 1;
          updateProgress();
        }
      }
    })());

    await Promise.all(workers);
    updateAssetUploadDialog("素材上传完成", { open: false });

    if (failed > 0) {
      showSnackbar(`媒体库保存完成（失败 ${failed} 个）`);
    } else {
      showSnackbar("媒体库保存完成");
    }
  } catch (error) {
    console.error("Error checking or uploading assets:", error);
    updateAssetUploadDialog("素材上传失败", { open: false });
    showErrorAlert("媒体库保存失败", buildErrorDescription(error));
  }
}

// --- Refactored fetchProjectInfo ---
async function fetchProjectInfo() {
  if (_pid === 0 || !Number.isInteger(_pid)) return;

  updateLoadingDescription("正在获取项目详细信息...");
  try {
    const result = await apiRequest({
      url: `${ZCConfig.api.getPath("/scratch/projectinfo2")}?id=${_pid}`,
      type: "GET",
    });

    if (result.status == "404") {
      location.href = `${ZCConfig.frontend.getPath("/editor.html")}?msg=404`;
      return;
    }

    projectinfo = result;
    if (!isEmbed) {
      authorinfocard.headline = result.author.username;
      authorinfocard.description = result.author.zcusername;
      authorinfocard.onclick = () => window.open(`${ZCConfig.frontend.getPath("/")}${result.author.zcusername}`);
      authorinfocard.style.cursor = "pointer";
      authorinfoavatar.src = `${ZCConfig.s3.staticUrl}/assets/${result.author.profile.id.slice(0,2)}/${result.author.profile.id.slice(2,4)}/${result.author.profile.id}.webp`;
      zctab.headline = `${result.title} #${result.id}`;
      zctab.description = `${
        String(result.author.id) === String(currentUserId)
          ? "是你的作品"
          : "不是你的作品"
      }`;

      if (String(result.author.id) !== String(currentUserId)) {
        setButton("push-button", "改编", () => window.open(`${ZCConfig.frontend.getPath("/projects/")}${_pid}/fork`));
      }
    }
  } catch (error) {
    console.error("Error fetching project info:", error);
    showErrorAlert("获取项目信息失败", buildErrorDescription(error));
  }
}


function updateZerocatTab() {
  if (zctab) {
    zctab.open = true;
  }
}

// --- Refactored getZerocatUserInfo ---
async function getZerocatUserInfo(userid) {
  try {
    const result = await $.ajax({
      url: `${ZCConfig.api.getPath("/user/id/")}${userid}`,
      type: "GET",
    });
    return result.data;
  } catch (error) {
    console.error(`Failed to get user info for ${userid}:`, error);
    showErrorAlert("获取用户信息失败", `无法加载用户 ${userid} 的信息。`);
    return null;
  }
}


// 在initialize函数开始处添加检查URL参数中是否有token信息
function checkUrlForTokens() {
  const urlParams = new URLSearchParams(window.location.search);
  const token = urlParams.get("token");
  const refreshToken = urlParams.get("refreshToken");

  if (token) {
    // 保存从URL获取的token
    TokenManager.saveTokens(token, refreshToken);

    // 清除URL中的token参数
    const url = new URL(window.location.href);
    url.searchParams.delete("token");
    url.searchParams.delete("refreshToken");
    url.searchParams.delete("expires_at");
    window.history.replaceState({}, "", url);

    // 重新加载用户信息
    loadUserInfo();
    return true;
  }

  return false;
}

let isEmbed;
function mountScratchToolShell() {
  if (AppState.uiMounted) return;

  if (!isEmbed) {
    if (!document.getElementById("zerocat-tab")) {
      document.body.insertAdjacentHTML(
        "beforeend",
        `
<mdui-dialog headline="作品" description="加载中" close-on-overlay-click id="zerocat-tab">
    <mdui-list>
        <mdui-list-subheader>作者</mdui-list-subheader>
        <mdui-list-item headline="作者信息" description="加载中" id="author-info" active rounded>
            <mdui-avatar slot="icon" src="" id="author-avatar"></mdui-avatar>
        </mdui-list-item>
        <mdui-list-subheader>当前提交</mdui-list-subheader>
        <mdui-list-item headline="提交信息" description="Supporting text" id="commit-info" rounded>
            <mdui-avatar slot="icon" src="" id="commit-avatar"></mdui-avatar>
        </mdui-list-item>
    </mdui-list>
    <br/>
    <mdui-button id="savestatic" onclick="uploadProjectAssets()">保存媒体库</mdui-button>
    <mdui-button onclick="openCommitDialog()">保存作品</mdui-button>
    <mdui-button onclick="openCloudToolDialog()">云变量工具</mdui-button>
    <mdui-button onclick="logText.value = ''">清空log</mdui-button>
    <mdui-text-field autosize readonly max-rows="5" variant="outlined" id="log-text"></mdui-text-field>
    <mdui-list style="margin-top: 10px;">
      <mdui-list-subheader>开发设置</mdui-list-subheader>
      <mdui-list-item headline="显示快捷保存按钮" description="开启后会显示开发环境保存按钮">
        <mdui-button slot="end-icon" id="setting-toggle-dev-quick-save" variant="outlined">已关闭</mdui-button>
      </mdui-list-item>
    </mdui-list>
</mdui-dialog>
`
      );
    }

    if (!document.querySelector(".loading-dialog")) {
      document.body.insertAdjacentHTML(
        "beforeend",
        `
<mdui-dialog
        headline="加载中"
        description="正在加载作品，请稍候..."
        close-on-overlay-click
        class="loading-dialog"
></mdui-dialog>
`
      );
    }

    if (!document.getElementById("commit-dialog")) {
      document.body.insertAdjacentHTML(
        "beforeend",
        `
<mdui-dialog headline="提交作品" description="请输入提交信息" close-on-overlay-click id="commit-dialog">
    <mdui-text-field variant="outlined" label="提交信息" value="Update Project" id="commit-message"></mdui-text-field>
    <mdui-text-field variant="outlined" label="更多信息" rows id="commit-description"></mdui-text-field>
    <mdui-radio-group value="main" id="commit-branch-mode">
        <mdui-radio value="main">提交给当前分支</mdui-radio>
        <mdui-radio value="pr">为此提交创建一个新分支</mdui-radio>
    </mdui-radio-group>
    <mdui-text-field variant="outlined" label="分支名称" value="main" id="branch-name"></mdui-text-field>
    <mdui-button onclick="commitProject()">提交</mdui-button>
</mdui-dialog>
`
      );
    }

    if (!document.getElementById("cloud-tool-dialog")) {
      document.body.insertAdjacentHTML(
        "beforeend",
        `
<mdui-dialog headline="云变量工具" description="遵守标准协议，与 Scratch 云变量实时同步" close-on-overlay-click id="cloud-tool-dialog">
    <mdui-text-field variant="outlined" label="Project ID" id="cloud-project-id"></mdui-text-field>
    <mdui-text-field variant="outlined" label="Handshake User" id="cloud-username"></mdui-text-field>
    <mdui-text-field variant="outlined" label="连接状态" readonly id="cloud-conn-status"></mdui-text-field>
    <mdui-text-field variant="outlined" label="云变量数量" readonly id="cloud-vars-count"></mdui-text-field>
    <mdui-button onclick="cloudConnect()">连接后端 WS</mdui-button>
    <mdui-button onclick="cloudDisconnect()">断开连接</mdui-button>
    <mdui-button onclick="cloudRefreshVariables()">刷新变量列表</mdui-button>
    <div id="cloud-vars-list" style="max-height: 380px; overflow: auto; margin-top: 8px;"></div>
</mdui-dialog>
`
      );
    }

    if (!document.getElementById("asset-upload-dialog")) {
      document.body.insertAdjacentHTML(
        "beforeend",
        `<mdui-dialog headline="保存素材" description="正在准备上传..." close-on-overlay-click id="asset-upload-dialog"></mdui-dialog>`
      );
    }
  } else if (!document.querySelector(".loading-dialog")) {
    document.body.insertAdjacentHTML(
      "beforeend",
      `
<mdui-dialog
        headline="加载中"
        description="正在加载作品，请稍候..."
        close-on-overlay-click
        class="loading-dialog"
        open
></mdui-dialog>
`
    );
  }

  AppState.uiMounted = true;
}

function cacheScratchToolElements() {
  if (isEmbed) return;
  zctab = document.querySelector("#zerocat-tab");
  authorinfocard = document.querySelector("#author-info");
  authorinfoavatar = document.querySelector("#author-avatar");
  logText = document.querySelector("#log-text");
  quickSaveSettingButton = document.querySelector("#setting-toggle-dev-quick-save");
  assetUploadDialog = document.querySelector("#asset-upload-dialog");
  commitDialogElement = document.querySelector("#commit-dialog");
  commitBranchNameInput = document.querySelector("#branch-name");
  commitBranchRadioGroup = document.querySelector("#commit-branch-mode") || document.querySelector("#commit-dialog mdui-radio-group");
  cloudDialog = document.querySelector("#cloud-tool-dialog");
  cloudProjectIdInput = document.querySelector("#cloud-project-id");
  cloudUsernameInput = document.querySelector("#cloud-username");
  cloudConnStatusInput = document.querySelector("#cloud-conn-status");
  cloudVarsCountInput = document.querySelector("#cloud-vars-count");
  cloudVarsListContainer = document.querySelector("#cloud-vars-list");

  if (cloudProjectIdInput && _pid > 0) {
    cloudProjectIdInput.value = String(_pid);
  }
  if (cloudUsernameInput) {
    cloudUsernameInput.value = getCloudUsername();
  }
  setCloudConnectionStatus("idle");
  scheduleCloudVariablesRender({ force: true });

  if (cloudDialog && !AppState.listeners.cloudDialogLifecycleBound) {
    cloudDialog.addEventListener("close", stopCloudSyncTimer);
    cloudDialog.addEventListener("closed", stopCloudSyncTimer);
    AppState.listeners.cloudDialogLifecycleBound = true;
  }
  applySavedSettings();
  bindQuickSaveSettingListener();
}

function initialize() {
  const tokenFromUrl = checkUrlForTokens();
  const urlParams = new URLSearchParams(window.location.search);
  isEmbed = urlParams.get("embed") === "true";

  mountScratchToolShell();
  cacheScratchToolElements();

  if (typeof ClipCCExtension !== "undefined") {
    zcvm = ClipCCExtension.api.getVmInstance();
    zcgui = ClipCCExtension.api.getGuiInstance();
  } else if (typeof window.vm !== "undefined") {
    zcvm = window.vm;
    zcgui = window.gui;
  } else {
    setTimeout(initialize, 100);
    return;
  }

  if (AppState.appInitialized) return;
  AppState.appInitialized = true;
  ResourceLoadTracker.install(zcvm);

  const msg = getQueryStringParameter("msg");
  if (msg) {
    if (msg === "404") alert("作品不存在");
    if (msg === "401") alert("未登录");
  }

  loadUserInfo();
  installCloudGlobalListeners();
  cloudAutoConnectIfNeeded({ force: tokenFromUrl });
  loadProject();
}

function zctabopen() {
  updateZerocatTab();
}

let isLoading = false;

// 更新loading对话框描述的函数
function updateLoadingDescription(description) {
  const loadingDialog = document.querySelector(".loading-dialog");
  if (loadingDialog) {
    loadingDialog.description = description;
  }
}

const ResourceLoadTracker = {
  active: false,
  total: 0,
  loaded: 0,
  failed: 0,
  wrapped: false,
  originalLoad: null,
  lastRenderAt: 0,
  install(vm) {
    if (this.wrapped) return;
    const storage = vm?.runtime?.storage;
    if (!storage || typeof storage.load !== "function") return;
    this.originalLoad = storage.load.bind(storage);
    const tracker = this;
    storage.load = function (...args) {
      const result = tracker.originalLoad(...args);
      if (!tracker.active) return result;
      return Promise.resolve(result)
        .then((asset) => {
          tracker.incrementLoaded(false);
          return asset;
        })
        .catch((error) => {
          tracker.incrementLoaded(true);
          throw error;
        });
    };
    this.wrapped = true;
  },
  start(total) {
    this.active = true;
    this.total = Math.max(0, Number(total) || 0);
    this.loaded = 0;
    this.failed = 0;
    this.render();
  },
  stop() {
    this.active = false;
  },
  incrementLoaded(failed) {
    if (!this.active) return;
    this.loaded += 1;
    if (failed) this.failed += 1;
    this.render();
  },
  render() {
    if (!this.active) return;
    const now = Date.now();
    if (now - this.lastRenderAt < RESOURCE_TRACKER_RENDER_INTERVAL_MS) return;
    this.lastRenderAt = now;
    if (this.total <= 0) {
      updateLoadingDescription("正在加载资源...");
      return;
    }
    const percent = Math.min(100, Math.floor((this.loaded / this.total) * 100));
    const failText = this.failed > 0 ? `，失败 ${this.failed}` : "";
    updateLoadingDescription(`正在加载资源 ${this.loaded}/${this.total} (${percent}%)${failText}`);
  },
};

async function checkExtensionVerification(projectData) {
  try {
    const extensionURLs = projectData?.extensionURLs;
    if (!extensionURLs || typeof extensionURLs !== 'object') return true;

    const apiPrefix = ZCConfig.api.url;
    const extIdRegex = /\/extensions\/(\d+)\.js$/;
    const ids = [];

    for (const [key, url] of Object.entries(extensionURLs)) {
      if (typeof url === 'string' && url.startsWith(apiPrefix)) {
        const match = url.match(extIdRegex);
        if (match) ids.push(Number(match[1]));
      }
    }

    if (ids.length === 0) return true;

    const response = await apiRequest({
      url: ZCConfig.api.getPath("/extensions/detail/batch"),
      type: "POST",
      data: JSON.stringify({ ids }),
      contentType: "application/json",
    });

    const unverified = (response.data || []).filter(item => !item.verified);
    if (unverified.length === 0) return true;

    const extList = unverified.map(item => {
      if (item.exists && item.data?.project?.title) {
        return `${item.data.project.title} (ID: ${item.id})`;
      }
      return `扩展 ID: ${item.id}`;
    }).join('\n');

    try {
      await mdui.confirm({
        headline: "扩展安全提示",
        description: `以下扩展未经验证，可能存在安全风险：\n\n${extList}\n\n是否仍然继续加载？`,
        confirmText: "继续加载",
        cancelText: "取消",
      });
      return true;
    } catch {
      return false;
    }
  } catch (error) {
    console.error("Extension verification check failed:", error);
    return true;
  }
}

async function extractInlineExtensions(projectJsonStr) {
  try {
    const projectData = JSON.parse(projectJsonStr);
    const extensionURLs = projectData?.extensionURLs;
    if (!extensionURLs || typeof extensionURLs !== 'object') return projectJsonStr;

    const inlineKeys = Object.entries(extensionURLs)
      .filter(([, url]) => typeof url === 'string' && url.startsWith('data:text/javascript;base64,'))
      .map(([key]) => key);

    if (inlineKeys.length === 0) return projectJsonStr;

    try {
      await mdui.confirm({
        headline: "检测到内联扩展",
        description: "作品包含内联 JavaScript 扩展代码，是否将其自动上传为扩展项目？点击「取消」将不会保存。",
        confirmText: "确认上传",
        cancelText: "取消",
      });
    } catch {
      return null;
    }

    for (const key of inlineKeys) {
      const dataUrl = extensionURLs[key];
      const base64 = dataUrl.replace('data:text/javascript;base64,', '');
      const jsSource = new TextDecoder().decode(Uint8Array.from(atob(base64), c => c.charCodeAt(0)));

      const randomSuffix = Math.floor(Math.random() * 900000) + 100000;
      const createResponse = await apiRequest({
        url: ZCConfig.api.getPath("/project/"),
        type: "POST",
        data: JSON.stringify({
          name: `${key}_${randomSuffix}`,
          title: key,
          type: "scratch-extension",
          state: "public",
          description: `由作品「${projectinfo?.title || _pid}」(ID: ${_pid}) 自动创建的扩展`,
        }),
        contentType: "application/json",
      });

      const newProjectId = createResponse.id;
      if (!newProjectId) {
        throw new Error(createResponse.message || "创建扩展项目失败");
      }

      const initResponse = await apiRequest({
        url: `${ZCConfig.api.getPath("/project/initlize")}?projectid=${newProjectId}&type=text`,
        type: "POST",
      });
      if (initResponse.status === "error") {
        throw new Error(initResponse.message || "初始化项目失败");
      }

      const saveResponse = await apiRequest({
        url: ZCConfig.api.getPath("/project/savefile"),
        type: "POST",
        data: jsSource,
        contentType: "text/plain; charset=UTF-8",
        processData: false,
      });
      if (!saveResponse.accessFileToken) {
        throw new Error(saveResponse.message || "保存扩展源码失败");
      }

      const accessFileToken = saveResponse.accessFileToken;

      const commitResponse = await apiRequest({
        url: `${ZCConfig.api.getPath("/project/commit/id/")}${newProjectId}`,
        type: "PUT",
        data: JSON.stringify({
          projectid: newProjectId,
          branch: "main",
          accessFileToken,
          message: "自动上传内联扩展",
        }),
        contentType: "application/json",
      });
      if (commitResponse.status === "error") {
        throw new Error(commitResponse.message || "提交扩展失败");
      }

      const extResponse = await apiRequest({
        url: ZCConfig.api.getPath("/extensions/manager/create"),
        type: "POST",
        data: JSON.stringify({
          projectid: newProjectId,
          branch: "main",
        }),
        contentType: "application/json",
      });

      const extId = extResponse.data.id;
      extensionURLs[key] = `${ZCConfig.api.url}/extensions/${extId}.js`;
    }

    showSnackbar(`已成功创建 ${inlineKeys.length} 个扩展项目`);
    return JSON.stringify(projectData);
  } catch (error) {
    console.error("Error extracting inline extensions:", error);
    showSnackbar(`提取内联扩展失败: ${error.responseJSON?.message || error.message || error.statusText}`);
    return null;
  }
}

function countProjectAssets(projectData) {
  const targets = Array.isArray(projectData?.targets) ? projectData.targets : [];
  let total = 0;
  for (const target of targets) {
    if (Array.isArray(target?.costumes)) total += target.costumes.length;
    if (Array.isArray(target?.sounds)) total += target.sounds.length;
  }
  return total;
}

function normalizeRefValue(ref) {
  return String(ref ?? "").trim();
}

function isLatestRefValue(ref) {
  return normalizeRefValue(ref).toLowerCase() === "latest";
}

function isSameCommitRef(leftRef, rightRef) {
  const left = normalizeRefValue(leftRef);
  const right = normalizeRefValue(rightRef);
  if (!left || !right) return false;
  return left === right;
}

async function warnIfRefIsNotLatest() {
  const ref = normalizeRefValue(getQueryStringParameter("ref"));
  if (!ref || isLatestRefValue(ref)) return;

  const branch = String(getQueryStringParameter("branch") || "main").trim() || "main";
  let latestCommitId = "";
  try {
    if (Number.isInteger(_pid) && _pid > 0) {
      const latestRemote = await fetchLatestRemoteProjectSnapshot(branch);
      if (!latestRemote?.exists) return;
      latestCommitId = normalizeRefValue(latestRemote?.commitId);
      if (isSameCommitRef(ref, latestCommitId)) {
        return;
      }
    }
  } catch (error) {
    console.warn("[load] failed to verify whether ref is latest:", error);
  }

  const warnedRef = `${branch}:${ref}`;
  if (AppState.load.warnedRef === warnedRef) return;
  AppState.load.warnedRef = warnedRef;

  const headline = "提交提示";
  const description = latestCommitId
    ? `当前 URL 使用 ref=${ref}，最新提交是 ${latestCommitId}，加载的是历史版本。`
    : `当前 URL 使用 ref=${ref}，这不是最后一次提交，加载的是历史版本。`;
  const switchToLatest = async () => {
    const url = new URL(window.location.href);
    url.searchParams.set("ref", "latest");
    window.history.replaceState({}, "", url);
    showSnackbar("已切换为加载最新版");
  };
  try {
    if (window.UIManager && window.mdui?.confirm) {
      try {
        await mdui.confirm({
          headline,
          description: `${description}\n\n是否立即加载最新版？`,
          confirmText: "加载最新版",
          cancelText: "继续当前版本",
        });
        await switchToLatest();
      } catch {
        // 用户选择继续当前版本，不做处理
      }
    } else {
      const shouldSwitch = confirm(`${headline}\n${description}\n\n点击“确定”加载最新版，点击“取消”继续当前版本。`);
      if (shouldSwitch) {
        await switchToLatest();
      }
    }
  } catch (error) {
    console.warn("[load] non-latest ref notice dismissed:", error);
  }
}

function validateBranchName(branchName) {
  const name = String(branchName || "").trim();
  if (!name) {
    return { ok: false, message: "分支名不能为空" };
  }
  if (name.length > 80) {
    return { ok: false, message: "分支名长度不能超过 80" };
  }
  if (!/^[A-Za-z0-9._\/-]+$/.test(name)) {
    return { ok: false, message: "分支名只能包含字母、数字、.、_、-、/" };
  }
  if (name.startsWith("/") || name.endsWith("/")) {
    return { ok: false, message: "分支名不能以 / 开头或结尾" };
  }
  if (name.startsWith(".") || name.endsWith(".")) {
    return { ok: false, message: "分支名不能以 . 开头或结尾" };
  }
  if (name.includes("..")) {
    return { ok: false, message: "分支名不能包含连续的 .." };
  }
  if (name.includes("//")) {
    return { ok: false, message: "分支名不能包含连续的 //" };
  }
  if (name.includes("@{")) {
    return { ok: false, message: "分支名不能包含 @{" };
  }
  if (name.endsWith(".lock")) {
    return { ok: false, message: "分支名不能以 .lock 结尾" };
  }
  return { ok: true, message: "" };
}

function setCommitBranchInputDisabled(disabled) {
  const branchNameInput = commitBranchNameInput || document.getElementById("branch-name");
  if (!branchNameInput) return;
  branchNameInput.disabled = disabled;
  if (disabled) {
    branchNameInput.setAttribute("disabled", "");
  } else {
    branchNameInput.removeAttribute("disabled");
  }
}

function getCommitBranchMode() {
  return String(commitBranchRadioGroup?.value || "main");
}

function isCreateBranchModeForSource(source) {
  return source === "commit-dialog" && getCommitBranchMode() === "pr";
}

function getExpectedExistingBranch() {
  return String(getQueryStringParameter("branch") || "main").trim();
}

function validateBranchPolicy({ source, branchName }) {
  const syntax = validateBranchName(branchName);
  if (!syntax.ok) {
    return { ok: false, message: syntax.message };
  }

  if (source === "commit-dialog" && getCommitBranchMode() !== "pr") {
    const expected = getExpectedExistingBranch();
    if (branchName !== expected) {
      return {
        ok: false,
        message: `当前模式只允许提交到当前分支 ${expected}，如需新分支请切换到“创建新分支”`,
      };
    }
  }

  return { ok: true, message: "" };
}

async function ensureBranchExistsOrAllowed({ source, branchName }) {
  const allowCreateBranch = isCreateBranchModeForSource(source);
  const remote = await fetchLatestRemoteProjectSnapshot(branchName);
  if (!remote.exists && !allowCreateBranch) {
    return {
      ok: false,
      message: `分支 ${branchName} 不存在。请切换到已有分支，或在提交弹窗中选择“创建新分支”。`,
      remote,
    };
  }
  return { ok: true, remote };
}

async function loadProject() {
  if (isLoading) return;
  isLoading = true;
  const requestSeq = ++AppState.load.seq;
  AppState.load.activeSeq = requestSeq;

  try {
    console.log("Loading project...");
    updateLoadingDescription("正在初始化项目加载...");

    const queryId = getQueryStringParameter("id");
    if (queryId) {
      _pid = Number(queryId);
      console.log(`Project ID from query: ${_pid}`);
      if (cloudProjectIdInput && Number.isInteger(_pid) && _pid > 0) {
        cloudProjectIdInput.value = String(_pid);
      }
      cloudAutoConnectIfNeeded({ force: true });
    }

    if (_pid === 0) {
      console.log("No project ID found, redirecting to new project page.");
      return;
    }

    await warnIfRefIsNotLatest();
    if (requestSeq !== AppState.load.activeSeq) return;

    console.log(`Fetching project info for ID: ${_pid}`);
    updateLoadingDescription("正在获取项目信息...");
    await fetchProjectInfo();
    if (requestSeq !== AppState.load.activeSeq) return;

    if (!zcvm) {
      updateLoadingDescription("正在等待Scratch引擎初始化...");
      setTimeout(loadProject, 100);
      return;
    }
    await downloadAndLoadProject(_pid, { requestSeq });
  } finally {
    if (requestSeq === AppState.load.activeSeq) {
      isLoading = false;
    }
  }
}

// --- Refactored downloadAndLoadProject & helpers ---
async function downloadAndLoadProject(pid, { requestSeq = null } = {}) {
  const isStale = () => requestSeq !== null && requestSeq !== AppState.load.activeSeq;
  console.log(`Downloading project with ID: ${pid}`);
  updateLoadingDescription("正在连接服务器获取项目数据...");

  const loadingDialog = document.querySelector(".loading-dialog");
  if (loadingDialog) {
    loadingDialog.open = true;
  }

  const branch = getQueryStringParameter("branch") || "main";
  const ref = getQueryStringParameter("ref") || "latest";
  const requestedRef = normalizeRefValue(ref);
  const requestedLatest = !requestedRef || isLatestRefValue(requestedRef);

  try {
    const response = await apiRequest({
      url: `${ZCConfig.api.getPath("/project/")}${pid}/${branch}/${ref}`,
      type: "GET",
    });
    if (isStale()) return;

    if (response.status === "error") {
      if (response.commit && response.commit.commit_message === "NoFirstCommit") {
        await handleUninitializedProject(pid);
      } else {
        showErrorAlert("加载失败", response.message, "关闭");
      }
      return;
    }

    const { commit, accessFileToken } = response;
    commitInfo = commit;

    // 更新URL查询参数，将commit.id和branch写入URL
    if (commit) {
      const url = new URL(window.location.href);
      const commitId = normalizeRefValue(commit.id || commit.commit_id);
      url.searchParams.set("ref", requestedLatest ? "latest" : (commitId || requestedRef));
      url.searchParams.set("branch", branch);
      window.history.replaceState({}, "", url);
    }

    updateLoadingDescription("正在获取项目文件数据...");
    await updateCommitInfoUI(commit);

    const fileResponse = await apiRequest({
      url: `${ZCConfig.api.getPath("/project/files/")}${commit.commit_file}?content=true`,
      type: "GET",
      data: { accessFileToken },
    });
    if (isStale()) return;

    updateLoadingDescription("正在解析项目数据...");
    // The response is the file content itself, not a JSON object containing it
    const projectData = JSON.parse(fileResponse);

    const canContinue = await checkExtensionVerification(projectData);
    if (!canContinue) {
      return;
    }

    const totalAssets = countProjectAssets(projectData);
    ResourceLoadTracker.start(totalAssets);
    await zcvm.loadProject(projectData);
    if (isStale()) return;
    ResourceLoadTracker.stop();

    console.log("Project loaded into VM successfully.");
    updateLoadingDescription("正在初始化Scratch引擎...");
    setTimeout(() => {
      if (isStale()) return;
      zcvm.renderer.draw();
    }, 10);
    zcvm.renderer.draw();

  } catch (error) {
    if (isStale()) return;
    console.error("Error downloading or loading project:", error);
    showErrorAlert(
      "加载失败",
      `作品加载失败: ${getErrorMessage(error)}`,
      "重新加载",
      () => window.location.reload()
    );
  } finally {
    if (!isStale() && loadingDialog) {
      loadingDialog.open = false;
    }
    ResourceLoadTracker.stop();
  }
}

async function handleUninitializedProject(pid) {
    updateLoadingDescription("检测到未初始化的项目，准备初始化...");
    const alertOptions = {
        headline: "作品未初始化",
        description: "你可以以Scratch模板初始化此作品",
        confirmText: "继续",
        onConfirm: async () => {
            updateLoadingDescription("正在初始化项目模板...");
            try {
                const response = await apiRequest({
                    url: `${ZCConfig.api.getPath("/project/edit/")}${pid}/init`,
                    type: "POST",
                });
                showSnackbar(response.message);
                updateLoadingDescription("项目初始化完成，重新加载...");
                await downloadAndLoadProject(pid);
            } catch (error) {
                console.error("Error initializing project:", error);
                showErrorAlert(
                    "初始化失败",
                    `作品初始化失败: ${getErrorMessage(error)}`,
                    "重新加载",
                    () => window.location.reload()
                );
            }
        },
    };

    if (window.UIManager) {
        UIManager.showAlert(alertOptions);
    } else {
        if (confirm(`${alertOptions.headline}: ${alertOptions.description}`)) {
            await alertOptions.onConfirm();
        }
    }
}

async function updateCommitInfoUI(commit) {
    if (isEmbed) return;
    try {
        const commitDate = new Date(commit.commit_date).toLocaleString();
        const commitInfoList = document.getElementById("commit-info");
        if (commitInfoList) {
            commitInfoList.headline = commit.commit_message;
            const commitInfoAvatar = document.getElementById("commit-avatar");
            const commitUser = await getZerocatUserInfo(commit.author_id);
            if (commitInfoAvatar && commitUser && commitUser.images) {
                commitInfoAvatar.src = `${ZCConfig.s3.staticUrl}/${commitUser.images}`;
            }
            if(commitUser) {
                commitInfoList.description = `${commitUser.display_name} 于 ${commitDate}`;
            }
        }
    } catch (error) {
        console.error("Failed to update commit info UI", error);
    }
}


function normalizeProjectJsonForCompare(raw) {
  try {
    return JSON.stringify(JSON.parse(String(raw ?? "")));
  } catch (error) {
    return String(raw ?? "").trim();
  }
}

function isLikelyMissingRemoteSnapshot(response) {
  const message = String(response?.message || "").toLowerCase();
  const code = String(response?.code || "").toLowerCase();
  if (response?.commit?.commit_message === "NoFirstCommit") return true;
  if (message.includes("nofirstcommit")) return true;
  if (message.includes("branch not found")) return true;
  if (message.includes("not found")) return true;
  if (message.includes("不存在")) return true;
  if (code.includes("404")) return true;
  return false;
}

async function fetchLatestRemoteProjectSnapshot(branchName) {
  const response = await apiRequest({
    url: `${ZCConfig.api.getPath("/project/")}${_pid}/${branchName}/latest`,
    type: "GET",
  });

  if (response?.status === "error") {
    if (isLikelyMissingRemoteSnapshot(response)) {
      return { exists: false, commit: response?.commit || null, commitId: null, json: "" };
    }
    throw new Error(response?.message || "获取云端最新提交失败");
  }

  const commit = response?.commit || null;
  const accessFileToken = response?.accessFileToken;
  const commitFile = commit?.commit_file;
  if (!commitFile || !accessFileToken) {
    return { exists: false, commit, commitId: commit?.id || commit?.commit_id || null, json: "" };
  }

  const fileResponse = await apiRequest({
    url: `${ZCConfig.api.getPath("/project/files/")}${commitFile}?content=true`,
    type: "GET",
    data: { accessFileToken },
  });

  const json = typeof fileResponse === "string" ? fileResponse : JSON.stringify(fileResponse);
  return {
    exists: true,
    commit,
    commitId: commit?.id || commit?.commit_id || null,
    json,
  };
}

async function compareWithLatestRemoteProject(branchName, localProjectJson) {
  const remote = await fetchLatestRemoteProjectSnapshot(branchName);
  return compareWithLatestRemoteProjectWithSnapshot(localProjectJson, remote);
}

function compareWithLatestRemoteProjectWithSnapshot(localProjectJson, remote) {
  if (!remote.exists) {
    return {
      remoteExists: false,
      different: true,
      reason: "no_remote_snapshot",
      remoteCommitId: remote.commitId,
    };
  }
  const localNormalized = normalizeProjectJsonForCompare(localProjectJson);
  const remoteNormalized = normalizeProjectJsonForCompare(remote.json);
  return {
    remoteExists: true,
    different: localNormalized !== remoteNormalized,
    reason: localNormalized !== remoteNormalized ? "content_different" : "content_same",
    remoteCommitId: remote.commitId,
  };
}

// 通用错误提示函数
function showErrorAlert(headline, description, confirmText = "关闭", onConfirm) {
  const options = {
    headline,
    description,
    confirmText,
  };

  if (onConfirm) {
    options.onConfirm = onConfirm;
  }

  if (window.UIManager) {
    UIManager.showAlert(options);
  } else {
    if (confirm(`${headline}: ${description}`)) {
      if (onConfirm) onConfirm();
    }
  }
}

function updateBranchInUrl(branchName) {
  const url = new URL(window.location.href);
  url.searchParams.set("branch", branchName);
  window.history.replaceState({}, "", url);
}

function onCommitBranchModeChange(event) {
  const branchNameInput = commitBranchNameInput || document.getElementById("branch-name");
  const branchRadioGroup = commitBranchRadioGroup || event.currentTarget;
  if (!branchNameInput || !branchRadioGroup) return;

  const currentBranch = branchRadioGroup.dataset.currentBranch || "main";
  const selectedMode = event.target?.value || branchRadioGroup.value;

  if (selectedMode === "pr") {
    const username = localStorage.getItem("zc:username") || "user";
    const timestamp = Date.now();
    const newBranchName = `${username}-patch-${timestamp}`;
    branchNameInput.value = newBranchName;
    setCommitBranchInputDisabled(false);
    updateBranchInUrl(newBranchName);
    return;
  }

  branchNameInput.value = currentBranch;
  setCommitBranchInputDisabled(true);
  updateBranchInUrl(currentBranch);
}

function ensureCommitDialogListener() {
  if (AppState.listeners.commitBranchChangeBound || !commitBranchRadioGroup) return;
  commitBranchRadioGroup.addEventListener("change", onCommitBranchModeChange);
  AppState.listeners.commitBranchChangeBound = true;
}

function openCommitDialog() {
  const commitDialog = commitDialogElement || document.getElementById("commit-dialog");
  const branchNameInput = commitBranchNameInput || document.getElementById("branch-name");
  if (!commitDialog || !branchNameInput) {
    console.error("提交对话框未初始化");
    showSnackbar("提交对话框未初始化");
    return;
  }
  commitDialogElement = commitDialog;
  commitBranchNameInput = branchNameInput;

  const branchRadioGroup = commitBranchRadioGroup || document.getElementById("commit-branch-mode") || document.querySelector("#commit-dialog mdui-radio-group");
  if (!branchRadioGroup) {
    console.error("分支选择未初始化");
    showSnackbar("分支选择未初始化");
    return;
  }
  commitBranchRadioGroup = branchRadioGroup;
  ensureCommitDialogListener();

  const currentBranch = getQueryStringParameter("branch") || "main";
  commitBranchRadioGroup.dataset.currentBranch = currentBranch;
  commitBranchRadioGroup.value = "main";
  branchNameInput.value = currentBranch;
  setCommitBranchInputDisabled(true);

  commitDialog.open = true;
}

function getSubmitProgressTexts(source) {
  if (source === "dev-quick-save") {
    return {
      start: "开发保存准备中...",
      uploadingAssets: "开发保存：上传素材...",
      serializing: "开发保存：序列化作品...",
      checkingRemote: "开发保存：校验云端...",
      extractingExtensions: "开发保存：处理扩展...",
      savingFile: "开发保存：保存文件...",
      committing: "开发保存：提交当前分支...",
    };
  }
  return {
    start: "保存准备中...",
    uploadingAssets: "保存中：上传素材...",
    serializing: "保存中：序列化作品...",
    checkingRemote: "保存中：校验云端...",
    extractingExtensions: "保存中：处理扩展...",
    savingFile: "保存中：保存文件...",
    committing: "保存中：提交分支...",
  };
}

async function submitProject({
  force = false,
  source = "commit-dialog",
  branchNameOverride = "",
  commitMessageOverride = "",
  commitDescriptionOverride = "",
  updateUrlBranchAfterCommit = true,
  progressButtonId = "save-button",
  idleButtonText = "保存",
  successButtonText = "保存完成",
  idleButtonHandler = () => openCommitDialog(),
} = {}) {
  if (AppState.save.inFlight) {
    showSnackbar("保存进行中，请稍候");
    return;
  }

  const branchNameInput = commitBranchNameInput || document.getElementById("branch-name");
  const commitMessageInput = document.getElementById("commit-message");
  const commitDescriptionInput = document.getElementById("commit-description");

  const hasSubmitForm = Boolean(branchNameInput && commitMessageInput && commitDescriptionInput);
  if (!hasSubmitForm && source !== "dev-quick-save") {
    showErrorAlert("错误", "提交表单未完全加载", "关闭");
    return;
  }
  if (!zcvm) {
    showErrorAlert("错误", "Scratch 引擎尚未就绪", "关闭");
    return;
  }
  if (!Number.isInteger(_pid) || _pid <= 0) {
    showErrorAlert("错误", "无效的项目 ID", "关闭");
    return;
  }

  const currentUrlBranch = String(getQueryStringParameter("branch") || "").trim();
  const branchName = String(branchNameOverride || currentUrlBranch || branchNameInput?.value || "main").trim();
  const commitMessageRaw = String(commitMessageInput?.value || "").trim();
  const commitDescriptionRaw = String(commitDescriptionInput?.value || "").trim();
  const commitMessage = String(commitMessageOverride || commitMessageRaw || "Update Project").trim();
  const commitDescription = String(commitDescriptionOverride || commitDescriptionRaw).trim();

  const branchPolicy = validateBranchPolicy({ source, branchName });
  if (!branchPolicy.ok) {
    showErrorAlert("分支名无效", branchPolicy.message, "关闭");
    if (source === "commit-dialog" && getCommitBranchMode() !== "pr" && branchNameInput) {
      const expected = getExpectedExistingBranch();
      branchNameInput.value = expected;
      setCommitBranchInputDisabled(true);
    }
    return;
  }

  if (!commitMessageRaw && !commitMessageOverride && source === "commit-dialog") {
    showErrorAlert("提交信息不能为空", "请输入提交信息", "关闭");
    return;
  }
  if (!branchName) {
    showErrorAlert("错误", "分支名不能为空", "关闭");
    return;
  }

  AppState.save.inFlight = true;
  const progressTexts = getSubmitProgressTexts(source);
  const setProgressButton = (text) => {
    if (text) setButton(progressButtonId, text, () => {});
  };
  setProgressButton(progressTexts.start);
  const commitDialog = commitDialogElement || document.getElementById("commit-dialog");
  if (commitDialog && source === "commit-dialog") commitDialog.open = false;

  let finalButtonText = idleButtonText;
  let finalButtonHandler = idleButtonHandler;

  try {
    AppState.save.phase = "uploadingAssets";
    setProgressButton(progressTexts.uploadingAssets);
    await uploadProjectAssets();

    if (zcvm?.runtime?.isRunning) {
      zcvm.runtime.stopAll();
    }

    AppState.save.phase = "serializing";
    setProgressButton(progressTexts.serializing);
    const currentProjectJson = zcvm.toJSON();

    if (String(projectinfo?.author?.id) !== String(currentUserId)) {
      showSnackbar("无权限");
      finalButtonText = "无权限";
      finalButtonHandler = () => {};
      return;
    }

    AppState.save.phase = "checkingRemote";
    setProgressButton(progressTexts.checkingRemote);
    const branchAvailability = await ensureBranchExistsOrAllowed({ source, branchName });
    if (!branchAvailability.ok) {
      showErrorAlert("分支不存在", branchAvailability.message, "关闭");
      return;
    }
    const remoteCompare = compareWithLatestRemoteProjectWithSnapshot(currentProjectJson, branchAvailability.remote);
    if (!remoteCompare.different) {
      showSnackbar("云端最新版本与当前内容一致。");
      return;
    }
    if (logText) {
      const remoteTag = remoteCompare.remoteCommitId ? `云端提交 ${remoteCompare.remoteCommitId}` : "云端暂无提交";
      logText.value += `[${getCurrentTime()}] 云端对比通过：${remoteTag}，准备提交。
`;
    }

    projectjson = currentProjectJson;

    AppState.save.phase = "extractingExtensions";
    setProgressButton(progressTexts.extractingExtensions);
    const processedJson = await extractInlineExtensions(projectjson);
    if (processedJson === null) {
      return;
    }
    projectjson = processedJson;

    AppState.save.phase = "savingFile";
    setProgressButton(progressTexts.savingFile);
    const saveResponse = await apiRequest({
      url: `${ZCConfig.api.getPath("/project/savefile")}?json=true`,
      type: "post",
      data: projectjson,
      contentType: "application/json",
    });

    const newAccessFileToken = saveResponse.accessFileToken;
    if (!newAccessFileToken) {
      throw new Error("保存文件后未返回 accessFileToken");
    }

    AppState.save.phase = "committing";
    setProgressButton(progressTexts.committing);
    const commitResponse = await apiRequest({
      url: `${ZCConfig.api.getPath("/project/commit/id/")}${_pid}`,
      type: "put",
      data: JSON.stringify({
        projectid: _pid,
        branch: branchName,
        accessFileToken: newAccessFileToken,
        message: commitMessage,
        commit_description: commitDescription,
      }),
      contentType: "application/json",
    });

    showSnackbar(commitResponse?.message || "保存完成");
    finalButtonText = successButtonText;
    if (logText) {
      logText.value += `[${getCurrentTime()}]保存完成
`;
    }

    if (updateUrlBranchAfterCommit) {
      updateBranchInUrl(branchName);
    }

  } catch (error) {
    console.error("Error committing project:", error);
    showErrorAlert("提交作品出错", buildErrorDescription(error), "关闭");
  } finally {
    AppState.save.inFlight = false;
    AppState.save.phase = "idle";
    setButton(progressButtonId, finalButtonText, finalButtonHandler);
  }
}


async function commitProject() {
  await submitProject({
    source: "commit-dialog",
    progressButtonId: "save-button",
    idleButtonText: "保存",
    successButtonText: "保存完成",
    idleButtonHandler: () => openCommitDialog(),
  });
}

async function saveProject({ force = false } = {}) {
  if (force) {
    showSnackbar("强制保存");
  }
  await submitProject({
    force,
    source: "quick-save",
    progressButtonId: "save-button",
    idleButtonText: "保存",
    successButtonText: "保存完成",
    idleButtonHandler: () => openCommitDialog(),
  });
}

async function quickSaveToDevelop() {
  await submitProject({
    force: true,
    source: "dev-quick-save",
    commitMessageOverride: "Develop Auto Save",
    commitDescriptionOverride: getCurrentDateTimeString(),
    updateUrlBranchAfterCommit: false,
    progressButtonId: "dev-save-button",
    idleButtonText: "开发环境保存",
    successButtonText: "开发保存完成",
    idleButtonHandler: () => quickSaveToDevelop(),
  });
}

function openBase64ImageInNewTab() {
  if (!zcvm) return;
  zcvm.renderer.requestSnapshot((dataURI) => {
    const imgWindow = window.open("", "_blank");
    imgWindow.document.write('<img src="' + dataURI + '"/>');
  });
}

async function setProjectThumbnail() {
  const buttonId = "set-thumbnail-button";
  const restoreButton = () => setButton(buttonId, "舞台截图设为封面", () => setProjectThumbnail());
  if (!zcvm) {
    setButton(buttonId, "Scratch 未就绪", () => setProjectThumbnail());
    setTimeout(restoreButton, 1200);
    return;
  }
  setButton(buttonId, "正在截图...", () => {});
  try {
    const dataURI = await new Promise(resolve => zcvm.renderer.requestSnapshot(resolve));
    setButton(buttonId, "正在上传封面...", () => {});
    const blob = await (await fetch(dataURI)).blob();
    const formData = new FormData();
    formData.append("file", blob, "thumbnail.png");

    const response = await apiRequest({
      url: `${ZCConfig.api.getPath("/scratch/thumbnail/")}${_pid}`,
      method: "POST",
      data: formData,
      processData: false,
      contentType: false,
    });

    if (response.status === "success") {
      setButton(buttonId, "封面设置成功", () => setProjectThumbnail());
      showSnackbar("封面设置成功");
    } else {
      setButton(buttonId, "封面设置失败", () => setProjectThumbnail());
      showSnackbar(`封面设置失败: ${response.message}`);
    }
  } catch (error) {
    console.error("Error setting project thumbnail:", error);
    setButton(buttonId, "封面设置失败", () => setProjectThumbnail());
    showSnackbar(`封面设置失败: ${getErrorMessage(error)}`);
  } finally {
    setTimeout(restoreButton, 1500);
  }
}
